package PhysicalDefect.patches;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.evacipated.cardcrawl.modthespire.lib.SpireField;
import com.evacipated.cardcrawl.modthespire.lib.SpirePatch;
import com.evacipated.cardcrawl.modthespire.lib.SpirePostfixPatch;
import com.evacipated.cardcrawl.modthespire.lib.SpirePrefixPatch;
import com.megacrit.cardcrawl.actions.utility.UseCardAction;
import com.megacrit.cardcrawl.cards.AbstractCard;
import com.megacrit.cardcrawl.cards.DamageInfo;
import com.megacrit.cardcrawl.characters.AbstractPlayer;
import com.megacrit.cardcrawl.core.AbstractCreature;
import com.megacrit.cardcrawl.core.Settings;
import com.megacrit.cardcrawl.dungeons.AbstractDungeon;
import com.megacrit.cardcrawl.helpers.FontHelper;
import com.megacrit.cardcrawl.monsters.AbstractMonster;
import com.megacrit.cardcrawl.powers.AbstractPower;

import PhysicalDefect.characters.MyPhysicalDefect;
import basemod.ReflectionHacks;

public class NegativeFocusPatches {

    @SpirePatch(clz = AbstractCard.class, method = SpirePatch.CLASS)
    public static class CardFields {
        // 标记是否为散射子弹
        public static SpireField<Boolean> isScatteredInstance = new SpireField<>(() -> false);
        // 【关键缓存】记录未被散射前的原始伤害，默认 -1
        public static SpireField<Integer> originalPreScatterDamage = new SpireField<>(() -> -1);
    }

    /**
     * 数学核心：仅在渲染层和首次计算时调用
     */
    public static int getScatteredDamage(AbstractPlayer p, int originalOutput, int focusAmt) {
        if (originalOutput <= 0)
            return 0;
        int mVal = Math.abs(focusAmt);

        int strengthAmt = 0;
        if (p.hasPower("Strength")) {
            strengthAmt = p.getPower("Strength").amount;
        }

        int strippedBase = originalOutput - strengthAmt;
        int basePerHit = Math.max(1, strippedBase / mVal);
        return basePerHit + strengthAmt;
    }

    // public static boolean isScatterCard(AbstractPlayer p, AbstractCard card) {
    // if (!(p instanceof MyPhysicalDefect))
    // return false;
    // if (card.type != AbstractCard.CardType.ATTACK)
    // return false;
    // // 如果是子弹卡，绝对不要再进散射逻辑，防止死循环和数值稀释
    // if (CardFields.isScatteredInstance.get(card))
    // return false;

    // boolean isAoe = ReflectionHacks.getPrivate(card, AbstractCard.class,
    // "isMultiDamage");
    // return !isAoe && card.damageTypeForTurn == DamageInfo.DamageType.NORMAL;
    // }
    public static boolean isScatterCard(AbstractPlayer p, AbstractCard card) {
        if (!(p instanceof MyPhysicalDefect))
            return false;
        if (card.type != AbstractCard.CardType.ATTACK)
            return false;

        // 【删除】不要在这里拦截子弹卡，否则子弹卡的数值计算会变回原版全额伤害
        // if (CardFields.isScatteredInstance.get(card))
        // return false;

        boolean isAoe = ReflectionHacks.getPrivate(card, AbstractCard.class, "isMultiDamage");
        return !isAoe && card.damageTypeForTurn == DamageInfo.DamageType.NORMAL;
    }

    // =================================================================
    // 1. 核心结算逻辑：信任 card.damage，执行多段 use()
    // =================================================================

    @SpirePatch(clz = UseCardAction.class, method = SpirePatch.CONSTRUCTOR, paramtypez = { AbstractCard.class,
            AbstractCreature.class })
    public static class ScatteringActionLogic {
        @SpirePrefixPatch
        public static void Prefix(UseCardAction __instance, AbstractCard card, AbstractCreature target) {
            // 【新增】在这里拦截递归：如果是衍生子弹，直接放行，让它作为普通卡打出，不要再分裂了
            if (CardFields.isScatteredInstance.get(card)) {
                return;
            }

            AbstractPlayer p = AbstractDungeon.player;
            if (!isScatterCard(p, card))
                return;

            AbstractPower focusPower = p.getPower("Focus");
            if (focusPower == null || focusPower.amount >= 0)
                return;

            int mVal = Math.abs(focusPower.amount);
            if (mVal <= 1)
                return;

            // --- 乱战/代码自动出牌兼容逻辑 ---
            // 如果 originalPreScatterDamage 为 -1，说明这张牌没经过渲染层的 applyPowers（可能是代码强行打出的）
            if (CardFields.originalPreScatterDamage.get(card) == -1) {
                // 此时手动调用一次计算，强制对齐数值
                card.calculateCardDamage(target instanceof AbstractMonster ? (AbstractMonster) target : null);
            }

            // 获取渲染层已经算好的单段伤害
            int splitDamage = card.damage;
            if (splitDamage <= 0)
                return;

            for (int i = 1; i < mVal; i++) {
                AbstractCard tmp = card.makeStatEquivalentCopy();
                CardFields.isScatteredInstance.set(tmp, true); // 标记为子弹，Patch 将不再拦截这张卡
                tmp.purgeOnUse = true;
                tmp.freeToPlayOnce = true;

                AbstractMonster randomTarget = AbstractDungeon.getMonsters().getRandomMonster(null, true,
                        AbstractDungeon.cardRandomRng);
                if (randomTarget != null) {
                    // 核心点：由于 tmp 标记为 isScatteredInstance，
                    // 这里的 calculateCardDamage 只会计算原版的 易伤/虚弱，不会再除以一次 M
                    tmp.calculateCardDamage(randomTarget);
                    tmp.use(p, randomTarget);
                }
            }
        }
    }

    // =================================================================
    // 2. 数据源头：CardValueDisplay (唯一计算点)
    // =================================================================
    @SpirePatch(clz = AbstractCard.class, method = "applyPowers")
    @SpirePatch(clz = AbstractCard.class, method = "calculateCardDamage")
    public static class CardValueDisplay {
        @SpirePostfixPatch
        public static void Postfix(AbstractCard __instance) {
            AbstractPlayer p = AbstractDungeon.player;
            if (p == null || !isScatterCard(p, __instance))
                return;

            AbstractPower focus = p.getPower("Focus");
            if (focus != null && focus.amount < 0) {
                // 1. 记录此时此刻的“真实原始伤害”
                CardFields.originalPreScatterDamage.set(__instance, __instance.damage);

                // 2. 计算并覆盖 damage 属性
                int splitDmg = getScatteredDamage(p, __instance.damage, focus.amount);
                if (__instance.damage > 0) {
                    __instance.damage = splitDmg;
                    __instance.isDamageModified = true;
                }
            } else {
                // 如果集中变正了，重置缓存
                CardFields.originalPreScatterDamage.set(__instance, -1);
            }
        }
    }

    // =================================================================
    // 3. UI 渲染 (右上角 xM)
    // =================================================================
    @SpirePatch(clz = AbstractCard.class, method = "render", paramtypez = { SpriteBatch.class })
    public static class CardRender {
        @SpirePostfixPatch
        public static void Postfix(AbstractCard __instance, SpriteBatch sb) {
            if (AbstractDungeon.player == null)
                return;
            if (isScatterCard(AbstractDungeon.player, __instance) && __instance.damage > 0) {
                AbstractPower focus = AbstractDungeon.player.getPower("Focus");
                if (focus != null && focus.amount < 0) {
                    int mVal = Math.abs(focus.amount);
                    if (mVal > 1) {
                        FontHelper.renderRotatedText(sb, FontHelper.cardEnergyFont_L, "x" + mVal,
                                __instance.current_x, __instance.current_y,
                                130.0F * __instance.drawScale * Settings.scale,
                                180.0F * __instance.drawScale * Settings.scale,
                                __instance.angle, true, Settings.GOLD_COLOR);
                    }
                }
            }
        }
    }
}